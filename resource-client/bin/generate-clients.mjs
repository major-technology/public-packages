#!/usr/bin/env node
/**
 * CLI tool to generate singleton resource clients
 * Part of @major-tech/resource-client
 * 
 * Usage:
 *   npx @major-tech/resource-client add <resource_id> <name> <type> <description> <application_id>
 *   npx @major-tech/resource-client remove <name>
 *   npx @major-tech/resource-client list
 * 
 * Types: database-postgresql | database-mssql | database-dynamodb | database-cosmosdb | database-snowflake | api-hubspot | api-googlesheets | api-custom | api-lambda | api-salesforce | storage-s3
 * 
 * Examples:
 *   npx @major-tech/resource-client add "abc-123" "orders-db" "database-postgresql" "Orders database" "app-123"
 *   npx @major-tech/resource-client add "xyz-789" "payment-api" "api-custom" "Payment API" "app-456"
 *   npx @major-tech/resource-client remove "orders-db"
 *   npx @major-tech/resource-client list
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// User's project root (where the command is run from)
const projectRoot = process.cwd();
const resourcesConfigPath = path.join(projectRoot, 'resources.json');

function getClientsDir() {
  const srcDir = path.join(projectRoot, 'src');
  if (fs.existsSync(srcDir)) {
    return path.join(srcDir, 'clients');
  }
  return path.join(projectRoot, 'clients');
}

/**
 * Client template
 */
function clientTemplate(data, framework) {
  const isNextJs = framework === 'nextjs';
  
  const imports = [
    `import { ${data.clientClass} } from '@major-tech/resource-client';`,
    isNextJs ? `import { headers } from 'next/headers';` : ''
  ].filter(Boolean).join('\n');

  const getHeadersConfig = isNextJs ? `
        getHeaders: async () => {
          const h = await headers();
          return {
            'x-major-user-jwt': h.get('x-major-user-jwt') || '',
          };
        },` : '';

  return `${imports}

/**
 * ${data.description}
 * 
 * Type: ${data.type}
 * Resource ID: ${data.resourceId}
 * Application ID: ${data.applicationId}
 * 
 * DO NOT EDIT - Auto-generated by @major-tech/resource-client
 */

const BASE_URL = ${isNextJs ? 'process.env.MAJOR_API_BASE_URL' : 'import.meta.env.MAJOR_API_BASE_URL'} || 'https://go-api.prod.major.build';
const MAJOR_JWT_TOKEN = ${isNextJs ? 'process.env.MAJOR_JWT_TOKEN' : 'import.meta.env.MAJOR_JWT_TOKEN'};

class ${data.clientName}Singleton {
  private static instance: ${data.clientClass} | null = null;

  static getInstance(): ${data.clientClass} {
    if (!${data.clientName}Singleton.instance) {
      ${data.clientName}Singleton.instance = new ${data.clientClass}({
        baseUrl: BASE_URL,
        majorJwtToken: MAJOR_JWT_TOKEN,
        applicationId: '${data.applicationId}',
        resourceId: '${data.resourceId}',
        fetch: (...args) => fetch(...args),${getHeadersConfig}
      });
    }
    return ${data.clientName}Singleton.instance;
  }
}

export const ${data.clientName} = ${data.clientName}Singleton.getInstance();
`;
}

/**
 * Index template
 */
function indexTemplate(data) {
  return `/**
 * Auto-generated client exports
 * DO NOT EDIT - Generated by @major-tech/resource-client
 */

${data.exports.join('\n')}
`;
}

/**
 * Load resources from JSON config file
 */
function loadResources() {
  if (!fs.existsSync(resourcesConfigPath)) {
    return [];
  }
  const content = fs.readFileSync(resourcesConfigPath, 'utf-8');
  return JSON.parse(content);
}

/**
 * Save resources to JSON config file
 */
function saveResources(resources) {
  const dir = path.dirname(resourcesConfigPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  fs.writeFileSync(resourcesConfigPath, JSON.stringify(resources, null, 2), 'utf-8');
}

/**
 * Convert a resource name to a valid camelCase identifier
 * e.g., "yo mama" -> "yoMama", "orders-db" -> "ordersDb"
 */
function toCamelCase(str) {
  return str
    .toLowerCase()
    .replace(/[^a-z0-9]+(.)/g, (_, char) => char.toUpperCase())
    .replace(/[^a-z0-9]+$/, '') // Remove trailing non-alphanumerics
    .replace(/^[^a-z]+/, ''); // Remove leading non-letters
}

function getClientClass(type) {
  const typeMap = {
    'database-postgresql': 'PostgresResourceClient',
    'database-mssql': 'MssqlResourceClient',
    'database-dynamodb': 'DynamoDBResourceClient',
    'database-cosmosdb': 'CosmosDBResourceClient',
    'database-snowflake': 'SnowflakeResourceClient',
    'api-custom': 'CustomApiResourceClient',
    'api-hubspot': 'HubSpotResourceClient',
    'api-googlesheets': 'GoogleSheetsResourceClient',
    'api-lambda': 'LambdaResourceClient',
    'api-salesforce': 'SalesforceResourceClient',
    'storage-s3': 'S3ResourceClient',
  };
  return typeMap[type] || 'PostgresResourceClient';
}

function generateClientFile(resource, framework) {
  const clientName = toCamelCase(resource.name) + 'Client';
  const clientClass = getClientClass(resource.type);

  return clientTemplate({
    clientClass,
    description: resource.description,
    type: resource.type,
    resourceId: resource.id,
    applicationId: resource.applicationId,
    clientName,
  }, framework);
}

function generateIndexFile(resources) {
  if (resources.length === 0) {
    return `// No clients configured\n`;
  }

  const exports = resources.map(resource => {
    const clientName = toCamelCase(resource.name) + 'Client';
    const fileName = toCamelCase(resource.name);
    return `export { ${clientName} } from './${fileName}';`;
  });

  return indexTemplate({ exports });
}

function addResource(resourceId, name, type, description, applicationId, framework) {
  const validTypes = ['database-postgresql', 'database-mssql', 'database-dynamodb', 'database-cosmosdb', 'database-snowflake', 'api-hubspot', 'api-googlesheets', 'api-custom', 'api-lambda', 'api-salesforce', 'storage-s3'];
  if (!validTypes.includes(type)) {
    console.error(`❌ Invalid type: ${type}`);
    console.error(`   Valid types: ${validTypes.join(', ')}`);
    console.error(`   Your resource-client version might be out of date. Try running 'pnpm update @major-tech/resource-client'`)
    process.exit(1);
  }

  if (!applicationId) {
    console.error('❌ Application ID is required');
    process.exit(1);
  }

  const resources = loadResources();
  
  const existing = resources.find(r => r.name === name);
  if (existing) {
    console.error(`❌ Resource with name "${name}" already exists`);
    process.exit(1);
  }
  
  const newResource = {
    id: resourceId,
    name,
    type,
    description,
    applicationId
  };
  
  resources.push(newResource);
  saveResources(resources);
  
  console.log(`✅ Added resource: ${name}`);
  console.log(`   Type: ${type}`);
  console.log(`   ID: ${resourceId}`);
  
  regenerateClients(resources, framework);
}

/**
 * Remove a resource by name
 */
function removeResource(name, framework) {
  const resources = loadResources();
  const index = resources.findIndex(r => r.name === name);
  
  if (index === -1) {
    console.error(`❌ Resource "${name}" not found`);
    process.exit(1);
  }
  
  const removed = resources.splice(index, 1)[0];
  saveResources(resources);
  
  console.log(`✅ Removed resource: ${removed.name}`);
  console.log(`   ID: ${removed.id}`);
  
  regenerateClients(resources, framework);
}

/**
 * List all resources
 */
function listResources() {
  const resources = loadResources();
  
  if (resources.length === 0) {
    console.log('No resources configured');
    return;
  }
  
  console.log(`Resources (${resources.length}):\n`);
  resources.forEach((r, idx) => {
    console.log(`${idx + 1}. ${r.name} (${r.type})`);
    console.log(`   ID: ${r.id}`);
    console.log(`   Client: ${toCamelCase(r.name)}Client`);
    console.log('');
  });
}

/**
 * Regenerate all client files
 */
function regenerateClients(resources, framework) {
  const clientsDir = getClientsDir();

  // Ensure clients directory exists
  if (!fs.existsSync(clientsDir)) {
    fs.mkdirSync(clientsDir, { recursive: true });
  }

  // Clear existing client files (except index.ts temporarily)
  const existingFiles = fs.readdirSync(clientsDir).filter(f => f !== 'index.ts');
  existingFiles.forEach(file => {
    fs.unlinkSync(path.join(clientsDir, file));
  });

  // Generate individual client files
  resources.forEach(resource => {
    const fileName = toCamelCase(resource.name) + '.ts';
    const filePath = path.join(clientsDir, fileName);
    const code = generateClientFile(resource, framework);
    fs.writeFileSync(filePath, code, 'utf-8');
  });

  // Generate index file
  const indexPath = path.join(clientsDir, 'index.ts');
  const indexCode = generateIndexFile(resources);
  fs.writeFileSync(indexPath, indexCode, 'utf-8');

  console.log(`✅ Generated ${resources.length} client(s) in ${clientsDir}`);
  if (framework) {
    console.log(`   Framework: ${framework}`);
  }
}

/**
 * Main execution
 */
function main() {
  const args = process.argv.slice(2);
  const command = args[0];
  
  // Extract --framework flag
  const frameworkIndex = args.indexOf('--framework');
  let framework = undefined;
  if (frameworkIndex !== -1 && args[frameworkIndex + 1]) {
    framework = args[frameworkIndex + 1];
    // Remove --framework and its value from args
    args.splice(frameworkIndex, 2);
  }
  
  if (!command) {
    console.log('Usage:');
    console.log('  npx @major-tech/resource-client add <resource_id> <name> <type> <description> <application_id> [--framework <nextjs|vite>]');
    console.log('  npx @major-tech/resource-client remove <name> [--framework <nextjs|vite>]');
    console.log('  npx @major-tech/resource-client list');
    console.log('\nTypes: database-postgresql | database-mssql | database-dynamodb | database-cosmosdb | database-snowflake | api-hubspot | api-googlesheets | api-custom | api-lambda | api-salesforce | storage-s3');
    return;
  }
  
  switch (command) {
    case 'add': {
      const [, resourceId, name, type, description, applicationId] = args;
      if (!resourceId || !name || !type || !description || !applicationId) {
        console.error('❌ Missing arguments');
        console.log('Usage: add <resource_id> <name> <type> <description> <application_id> [--framework <nextjs|vite>]');
        process.exit(1);
      }
      addResource(resourceId, name, type, description, applicationId, framework);
      break;
    }
    
    case 'remove': {
      const [, name] = args;
      if (!name) {
        console.error('❌ Missing name');
        process.exit(1);
      }
      removeResource(name, framework);
      break;
    }
    
    case 'list': {
      listResources();
      break;
    }

    default: {
      console.error(`❌ Unknown command: ${command}`);
      process.exit(1);
    }
  }
}

main();

